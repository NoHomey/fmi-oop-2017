# Защо ни е капацитет на динамичния масив

Задачата: да поддържаме динамичен масив, в който да може да добавяме произвелен брой елементи.

Очевидно не може просто да кажем нещо от рода на:
	
	int arr[100];
	
защото при добавянето на 101-вия елемент паметта ще се напълни.
Ще трябва да заделим памет в хийпа и при всяко нейно запълване да заделяме нова памет. 
Въпросът е колко да е тази памет и как точно да реализираме добавянето на елемент.

Има две основни идеи. Всички динамични масиви, написани на упражненията, са реализирани по по-добрия начин.

## Лошата идея

За един масив е важно да пазим елементите в него и колко са на брой, така че е достатъчно
през цялото време заделената памет да е точно толкова голяма, колкото са елементите в масива.
И да пазим този размер в една променлива (size).
Звучи добре, обаче програмата ще работи меко казано бавно.
Всяко добаване на елемент би изглеждало така:

    Нека имаме масив с N елемента.
    arr -> [11, 12, 13, 14, 15]
    
    Искаме да добавим още един, но няма място за него в края на масива.
    arr -> [11, 12, 13, 14, 15] ? ? ? ?
                                ^
                                Паметта тук не сме я заделили и нямаме право да я ползваме.
                                 
    Трябва да заделим нова памет чрез помощен указател.
    Естествено, избираме новият буфер да е с 1 по-дълъг.
    arr -> [11, 12, 13, 14, 15]
    tmp -> [ ?,  ?,  ?,  ?,  ?,  ?]
    
    Копираме всичко в новата памет (стават общо N копирания на елементи) и добавяме новия елемент накрая.
    arr -> [11, 12, 13, 14, 15]
    tmp -> [11, 12, 13, 14, 15, 16]
    
    Сега трябва да изтрием старата памет, да не заема място.
    arr -> X
    tmp -> [11, 12, 13, 14, 15, 16]
    
    И да насочим arr към новата памет. tmp също ще сочи натам, но това не е проблем.
    arr -> [11, 12, 13, 14, 15, 16]
    
Всеки път при добавяне на елемент се извършват N + 1 присвоявания на стойности на елементи на масива.
Ако започнем с празен масив и добавим 1000 елемента в него, горният прооцес ще се изпълни 1000 пъти и ще са необходими

    (0 + 1) + (1 + 1) + (2 + 1) + ... + (999 + 1) = 1 + 2 + ... + 1000 = 500500

присвоявания.

## Добрата идея

Тя е да направим така, че през повечето време да има празно място зад масива и да заделяме нова памет само в редки случаи.
Това може да стане, например, ако в началото заделим памет за k елемента (k - някакво положително число, често се избира степен на 2)
и когато тя се напълни, заделим по-голяма памет, после още по-голяма и т.н. Колко по-голяма да е всяка следваща памет?
Добра идея е да е двойно по-голяма:

    Нека изберем k = 4. Започваме с памет за 4 елемента, без да им даваме стойност.
    arr -> [ ?,  ?,  ?,  ?]
    
    Добавяме елемент:
    arr -> [ 1,  ?,  ?,  ?]
    
    Още един:
    arr -> [11, 12,  ?,  ?]
    
    И още един:
    arr -> [11, 12, 13,  ?]
    
    И още един:
    arr -> [11, 12, 13, 14]
    
    Дотук 4 присвоявания за 4 елемента. По другия начин щяха да са 10 присвоявания.
    
    Сега вече няма повече място. Ако искаме да добавим още нещо, трябва да заделим нова памет.
    arr -> [11, 12, 13, 14]
    tmp -> [ ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?]
    
    arr -> [11, 12, 13, 14]
    tmp -> [11, 12, 13, 14,  ?,  ?,  ?,  ?]
    
    arr -> X
    tmp -> [11, 12, 13, 14,  ?,  ?,  ?,  ?]
    
    arr -> [11, 12, 13, 14,  ?,  ?,  ?,  ?]
    
    Супер! Вече има място. Да добавим един елемент.
    arr -> [11, 12, 13, 14, 15,  ?,  ?,  ?]
    
    И още един:
    arr -> [11, 12, 13, 14, 15, 16,  ?,  ?]
    
    И още един:
    arr -> [11, 12, 13, 14, 15, 16, 17,  ?]
    
    И още един:
    arr -> [11, 12, 13, 14, 15, 16, 17, 18]
    
    Пак стигнахме до момент, в който няма повече място. Отново заделяме нова памет.
    arr -> [11, 12, 13, 14, 15, 16, 17, 18]
    tmp -> [ ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?]
    
    arr -> [11, 12, 13, 14, 15, 16, 17, 18]
    tmp -> [11, 12, 13, 14, 15, 16, 17, 18,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?]
    
    arr -> X
    tmp -> [11, 12, 13, 14, 15, 16, 17, 18,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?]
    
    arr -> [11, 12, 13, 14, 15, 16, 17, 18,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?]
    
    Отново има място! Да добавим елемент още веднъж.
    arr -> [11, 12, 13, 14, 15, 16, 17, 18, 19,  ?,  ?,  ?,  ?,  ?,  ?,  ?]
    
    И още веднъж.
    arr -> [11, 12, 13, 14, 15, 16, 17, 18, 19, 20,  ?,  ?,  ?,  ?,  ?,  ?]
    
    И т.н.
    
Тъй като всеки път, когато заделяме памет, заделяме двойно повече от преди, а 1000 е приблизително 2^10,
за слагането на 1000 елемента в масива ще са необходими не повече от 10 нови заделяния на памет.
А присвояванията ще са само около 2000 (защо?). Доста по-добре от 1000 заделяния на памет с 500500 присвоявания.

Е, тъй като броят на елементите в масива и размера на заделената памет вече са две различни числа,
трябва да ги пазим 2 променливи. Затова вместо да имаме само size, имаме size и capacity.